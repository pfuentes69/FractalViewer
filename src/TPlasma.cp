/***** * TPlasma.cp * * Drawing clouds (Perlin noise?)  * *****/#include <Packages.h>			// for NumToString prototype#include "TFractalViewerWindow.h"#include "TPlasma.h"#include <stdlib.h>#include <math.h>/**** *	TFractalViewerWindow constructor * *		Create a bullseye window. This constructor relies *		on the TWindow constructor to place the window in *		in attractive place. Then it appends a number to the *		window title. * ****/TPlasma::TPlasma(void){		//	Set the width, and show the window.			SetStyle(5);	Show();}/**** * Hit * *		Handle a mouse down in the window. *		Bullseye window just force a refresh. * ****/    /**** * Noise calculations * * ****/    float TPlasma::Noise(int x, int y){	int n = x + y * 57;	n = (n<<13) ^ n;	return (1.0 - ( (n * ((n * n * 15731) + 789221) +  1376312589) & 0x7fffffff) / 1073741824.0);}float TPlasma::CosineInterpolate(float a, float b, float x){	float ft = x * PI;	float f = (1 - cos(ft)) * 0.5;	float result =  a*(1-f) + b*f;	return result;}float TPlasma::SmoothNoise2D(float x, float y){ 	float corners = ( Noise(x-1, y-1) + Noise(x+1, y-1) + Noise(x-1, y+1) + Noise(x+1, y+1) ) / 16;	float sides   = ( Noise(x-1, y) + Noise(x+1, y) + Noise(x, y-1) + Noise(x, y+1) ) /  8;	float center  =  Noise(x, y) / 4;		return corners + sides + center;} float TPlasma::InterpolatedNoise(float x, float y){ 	int x_whole = (int) x;	float x_frac = x - x_whole;	int y_whole = (int) y;	float y_frac = y - y_whole;	float v1 = SmoothNoise2D(x_whole, y_whole);	float v2 = SmoothNoise2D(x_whole, y_whole+1);	float v3 = SmoothNoise2D(x_whole+1, y_whole);	float v4 = SmoothNoise2D(x_whole+1, y_whole+1);	float i1 = CosineInterpolate(v1,v3,x_frac);	float i2 = CosineInterpolate(v2,v4,x_frac);	return CosineInterpolate(i1, i2, y_frac);}float TPlasma::PerlinNoise2D(float x, float y){	int octaves=5;	float persistence=0.5;	float total = 0;		for (int i=0; i<octaves-1; i++) {		float frequency = pow(2,i);		float amplitude = pow(persistence,i);		total = total + InterpolatedNoise(x * frequency, y * frequency) * amplitude;	}		return total;}/**** * DrawShape methods * *		These are the DrawShape methods for *			TBullWindow:	does nothing *			TCircleBull:	Circles *			TSquareBull:	Squares *			TPlasma:	"Triangles" * *		All the DrawShape methods take a drawingRect *		as a parameter. The pen width *		is already set to the appropriate width. * ****/void TPlasma::DrawShape(Rect *drawingRect){	RGBColor colPix;		sWidth = drawingRect->right - drawingRect->left + 1;	sHeigth = drawingRect->bottom - drawingRect->top + 1;/* Not working yet!!!	for (int y=0; y<sHeigth; y++) {		for(int x=0; x<sWidth; x++) {//			seed2+=1;			float Val=PerlinNoise2D(x,y);//			Val = Val/2.0;//			Val = (Val + 1.0) / 2.0;			colPix.red = 32767; //65535 / Val;			colPix.green = 65535 / Val;			colPix.blue = 0; //65535 / Val;			SetCPixel(x, y, &colPix);		}	}*//* Test code to draw stuff using DrawPicture. It crashes for complex images (memory issues?)	OpenCPicParams	myOpenCPicParams;	PicHandle	myPic;	Rect 	rect;	rect.left = drawingRect->left;	rect.right = drawingRect->right;	rect.top = drawingRect->top;	rect.bottom = drawingRect->bottom;	myOpenCPicParams.srcRect = rect;	myOpenCPicParams.hRes = 0x00480000;	myOpenCPicParams.vRes = 0x00480000;	myOpenCPicParams.version = -2;	myOpenCPicParams.reserved1 = 0;	myOpenCPicParams.reserved2 = 0;		myPic = OpenCPicture(&myOpenCPicParams);		PenSize(style, style);	ClipRect(drawingRect);		while (drawingRect->left < drawingRect->right &&			drawingRect->top  < drawingRect->bottom) {		MoveTo(drawingRect->left, drawingRect->bottom);			LineTo(drawingRect->right, drawingRect->bottom);		LineTo(drawingRect->left, drawingRect->top);		LineTo(drawingRect->left, drawingRect->bottom);		InsetRect(drawingRect, style*2, style*2);	}		ClosePicture();	DrawPicture(myPic, &rect);*/}//// PREPARE STYLES METHODS////// ZOOM CONTENT//