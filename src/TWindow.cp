/***** * TWindow.c * *	Copyright © 1991 Symantec Corporation. All rights reserved. * *	Generic window class to handle most window actions. *	This class is intended to demonstrate the new *	object-oriented features of THINK C 5.0. It is not *	intended to be a general purpose window class for use *	in commerical-quality applications. * *	We store the object in the window's refCon and set *	the windowKind to TWINDOWKIND so we can tell whether *	there's an object in it. * *****/#include <oops.h>#include "TWindow.h"	 //		Prototypes for utility functions.static void EraseScrollBars (WindowPtr	theWindow);static void InvalScrollBars (WindowPtr	theWindow);static void ValidScrollBars (WindowPtr	theWindow);short TWindow::windowCounter = 0;			// the window counter that this class uses to 											// stack its windows/**** * TWindow constructor * *		Create a new window and place it in an *		attractive place on the screen. * ****/TWindow::TWindow(void){	Rect	myRect;	short	offset;	Point	originPt;			theWindow = GetNewCWindow(TWinRSRC, NULL, (void *) -1L);	drag = screenBits.bounds;	SetRect(&smallest, 60, 60, 9999, 9999);		((WindowPeek) theWindow)->windowKind = TWINDOWKIND;	SetWRefCon(theWindow, (long) this);	SetPort(theWindow);		//	Place this window in some attractive place		//	on the screen. TWindow uses the class variable		//	windowCounter to keep track of how many windows it		//	has stacked, but subclasses can access this variable		//	through the GetWindowNumber() method to create		//	numbered windows.	originPt = topLeft(theWindow->portRect);	LocalToGlobal(&originPt);	offset = ((windowCounter) % 7) * 20;	MoveWindow(theWindow, originPt.h+offset, originPt.v+offset, true);	windowCounter++;}/**** * TWindow destructor * *		Dispose of the window. * ****/TWindow::~TWindow(void){	DisposeWindow(theWindow);}/**** * Close * *		Close a window. *		This method merely deletes the object. * ****/void	TWindow::Close(){	delete this;}/**** * GetWindowCounter * *		Return the current value of the windowCounter *		instance variable. * ****/short TWindow::GetWindowNumber (void){	return	windowCounter;}/**** * Draw * *		Draw the contents of the window. *		This method sets the foreground and background *		color, erases the window, draws the scroll area *		in white, and finally draws the grow icon. * ****/void	TWindow::Draw(){	EraseRect(&theWindow->portRect);	BackColor(whiteColor);	EraseScrollBars(theWindow);	DrawGrowIcon(theWindow);}void	TWindow::Hit(Point where){	// Subclasses must do something here}/**** * Grow * *		Grow the window. *		If the window actually changed size, erase the *		scroll bar areas. Return the new size of the window. * ****/long TWindow::Grow (Point	where){	long	size;	Rect	smallest;	smallest = this->smallest;	// can't pass the address of								// and instance variable to								// a Toolbox routine that may								// move memory.		SetPort(theWindow);	size = GrowWindow(theWindow, where, &smallest);	if (size) {		EraseScrollBars(theWindow);		RefreshWindow(true);	// force whoe window to be redrawn								// the "true" param to SizeWindow								// accumulates the new area into								// the update region		SizeWindow(theWindow, LoWord(size), HiWord(size), true);	}		return (size);}/**** * Zoom * *		Zoom a window in reponse to a click in the zoom box. * ****/void	TWindow::Zoom (short part){	Rect	myRect;		SetPort(theWindow);	EraseRect(&theWindow->portRect);	ZoomWindow(theWindow, part, true);}/**** * Update * *		Update a window. *		The usual thing to do here is to call the Draw() *		method. * ****/void	TWindow::Update(void){	WindowPtr	savePort;		GetPort(&savePort);	SetPort(theWindow);	BeginUpdate(theWindow);	Draw();	EndUpdate(theWindow);	SetPort(savePort);}/**** * Activate * *		Respond to activate events. *		All we really have to do is make sure that the *		grow icon is drawn correctly. Subclasses that *		want to do something special when deactivate should *		override this method. * ****/void	TWindow::Activate (short active){	DrawGrowIcon(theWindow);	// DrawGrowIcon knows how to draw the icon								// for inactive & active windows		if (active)	  SetPort(theWindow);}/**** * Draw * Select * Show * Hide * TrackClose * TrackZoom * IsVisible * GetWindowTitle * SetWindowTitle * *		Various OOP interfaces to the Toolbox routines. * ****/void	TWindow::Drag(Point	where){	DragWindow(theWindow, where, &drag);}void	TWindow::Select(void){	SelectWindow(theWindow);}void	TWindow::Show(void){	ShowWindow(theWindow);}void	TWindow::Hide(void){	HideWindow(theWindow);}void	TWindow::TrackClose (Point where){	if (TrackGoAway(theWindow, where))		Close();}void	TWindow::TrackZoom(Point where, short part){	if (TrackBox(theWindow, where, part))		Zoom(part);}short	TWindow::IsVisible(){	return ((WindowPeek) theWindow)->visible;}void TWindow::GetWindowTitle (Str255 theTitle){	GetWTitle(theWindow, theTitle);}void TWindow::SetWindowTitle (Str255 theTitle){	SetWTitle(theWindow, theTitle);}/**** * GetWindowRect * *		Return the windows rectangle. *		This method is provided so subclasses don't have *		to go poking into the instance variables. * ****/void TWindow::GetWindowRect (Rect *theRect, Boolean entireWindow){	*theRect = theWindow->portRect;	if (!entireWindow) {		theRect->top += 1;		theRect->left += 1;		theRect->right -= 16;		theRect->bottom -= 16;	}}/**** * RefreshWindow * *		Force a window to be redrawn on the next udpate event. *		The Boolean parameter determines whether the scroll bars *		should be redrawn or not. * ****/void TWindow::RefreshWindow (Boolean wholeWindow){	InvalRect(&theWindow->portRect);	if (!wholeWindow)		ValidScrollBars(theWindow);}/**** * Zoom * ****/void	TWindow::ZoomContent(short z){	// Child will do}/*** * Utility routines to validate & inval the scroll bar rectangles. * ***/typedef enum { kInval, kValid, kErase } sbarAction;static void xScrollBars (WindowPtr theWindow, sbarAction action){	Rect	botRect;	Rect	rightRect;		rightRect = botRect = theWindow->portRect;  	botRect.top = botRect.bottom-15;			// The bottom scroll area    	rightRect.left = rightRect.right-15;		// The right scroll area	switch (action) {		case kInval:	InvalRect(&botRect);						InvalRect(&rightRect);						break;		case kValid:	ValidRect(&botRect);						ValidRect(&rightRect);						break;		case kErase:	EraseRect(&botRect);						EraseRect(&rightRect);						break;	}}static void InvalScrollBars (WindowPtr	theWindow){	xScrollBars(theWindow, kInval);}static void ValidScrollBars (WindowPtr	theWindow){	xScrollBars(theWindow, kValid);}static void EraseScrollBars (WindowPtr	theWindow){	xScrollBars(theWindow, kErase);}