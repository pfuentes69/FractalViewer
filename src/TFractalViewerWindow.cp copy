/***** * TFractalViewerWindow.c * *	Copyright © 1991 Symantec Corporation. All rights reserved. * *		The window methods for the Object Bullseye demo. * *		TBullWindow inherits its Draw method from TWindow. *		TSquareBull and TCircleBull override DrawShape to draw their own kind of bullseye. * *****/#include <Packages.h>			// for NumToString prototype#include "TFractalViewerWindow.h"#include <stdlib.h>/*** * concatenate two Pascal strings * ***/static void concat (StringPtr s, StringPtr p){	BlockMove(p+1, s+1+s[0], (long) p[0]);	s[0] += p[0];	}/**** *	TFractalViewerWindow constructor * *		Create a bullseye window. This constructor relies *		on the TWindow constructor to place the window in *		in attractive place. Then it appends a number to the *		window title. * ****/TFractalViewerWindow::TFractalViewerWindow(void){	Str15	numStr;	Str255	title;	long	windowNumber;				//	Set the title of the window to be		//	the title in the resource		//	plus the window counter.		//	The window counter is a class variable		//	declared in the TWindow class.	GetWindowTitle(title);	windowNumber = GetWindowNumber();	NumToString(GetWindowNumber(), numStr);	concat(title, numStr); 	SetWindowTitle(title);}TMandelbrot::TMandelbrot(void){		//	Set the width, and show the window.	PrepareStyles();	SetStyle(1);		// Set the default plane	DefaultPlane();		Show();}TJulia::TJulia(void){		//	Set the style, and show the window.			PrepareStyles();	SetStyle(1);		Show();}TPlasma::TPlasma(void){		//	Set the width, and show the window.			SetStyle(5);	Show();}/**** * Hit * *		Handle a mouse down in the window. *		Bullseye window just force a refresh. * ****/void TMandelbrot::DefaultPlane(){	pWidth = 3.0;	pHeigth = 3.0;	pCX = -0.6;	pCY = 0.0;}void TFractalViewerWindow::Hit(Point where){	RefreshWindow(false);		// preserve the scroll bars}void TMandelbrot::Hit(Point where){	Point 	mouse;	double	sCX, sCY, tX, tY, hX, hY;	Rect	drawingRect;	// Recalculate center	GlobalToLocal(&where);	hX = where.h; // - sLeft;	hY = where.v; // - sTop;		sCX = sWidth / 2.0;	sCY = sHeigth / 2.0;	tX = sCX - hX;	tY = hY - sCY;	pCX = pCX - pWidth * tX / (double)sWidth;		pCY = pCY - pHeigth * tY / (double)sHeigth;	RefreshWindow(false);		// preserve the scroll bars}/**** * GetStyle * SetStyle * *		Get and set the color style * ****/short	TFractalViewerWindow::GetStyle(){	return style;}void	TFractalViewerWindow::SetStyle(short w){	style = w;	RefreshWindow(true);}/**** * Draw * *		Draw the bullseye figures. *		Repeatedly call DrawShape with a smaller drawing area. *		The drawing area gets smaller by 2 * the width. * ****/void	TFractalViewerWindow::Draw(void){	RgnHandle	saveClip = NewRgn();	PenState	pen;	Rect		drawingRect;			GetPenState(&pen);	GetClip(saveClip);		inherited::Draw();		GetWindowRect(&drawingRect, false);		// Don't draw in the scroll											// bar areas. Note that it's											// ok to pass the address of											// drawingRect because											// GetWindowRect won't move											// memory.		sTop = drawingRect.top;	sLeft = drawingRect.left;												DrawShape(&drawingRect);	SetClip(saveClip);	DisposeRgn(saveClip);	SetPenState(&pen);	}/**** * DrawShape methods * *		These are the DrawShape methods for *			TBullWindow:	does nothing *			TCircleBull:	Circles *			TSquareBull:	Squares *			TPlasma:	"Triangles" * *		All the DrawShape methods take a drawingRect *		as a parameter. The pen width *		is already set to the appropriate width. * ****/void TFractalViewerWindow::DrawShape(Rect *drawingRect){}int TMandelbrot::Mandelbrot(double real, double imag, int maxiterations) {	double zReal = real;	double zImag = imag;		for (int i = 0; i < maxiterations; ++i) {		double r2 = zReal * zReal;		double i2 = zImag * zImag;		if (r2 + i2 > 10.0)			return i;		zImag = 2.0 * zReal * zImag + imag;		zReal = r2 - i2 + real;	}	return maxiterations;}void TMandelbrot::DrawShape(Rect *drawingRect){	int max_iteration = 100;	RGBColor colPix;	short st = GetStyle() - 1;	sWidth = drawingRect->right - drawingRect->left + 1;	sHeigth = drawingRect->bottom - drawingRect->top + 1;	double x_start = pCX - pWidth / 2.0;	double x_fin = x_start + pWidth;	double y_start = pCY - pHeigth / 2.0;	double y_fin = y_start + pHeigth;		double dx = (x_fin - x_start)/(sWidth - 1);	double dy = (y_fin - y_start)/(sHeigth - 1);	for (int i = 0; i < sHeigth; i++) {		for (int j = 0; j < sWidth; j++) {			double x = x_start + j*dx; // current real value			double y = y_fin - i*dy; // current imaginary value						int value = Mandelbrot(x, y, max_iteration);			value = 255 * value / max_iteration;			colPix = spec[st][value % 255];			SetCPixel(j, i, &colPix);		}	}}void TJulia::DrawShape(Rect *drawingRect){	RGBColor spec[256];	RGBColor colPix;	int WIDTH = drawingRect->right - drawingRect->left + 1;	for (auto ci=0; ci < 256; ci++) {		spec[ci].red = 0;		spec[ci].green = 65536 - ci * 256;		spec[ci].blue = ci * 256;	}	for (auto x = 0; x < WIDTH; x = x + 1) {		colPix = spec[x % 255];		SetCPixel(x, 0, &colPix);		SetCPixel(x, 1, &colPix);		SetCPixel(x, 2, &colPix);		SetCPixel(x, 3, &colPix);		SetCPixel(x, 4, &colPix);	}	/*	unsigned short 	x, y;	RGBColor colPix;	float r, g, b, WIDTH, HEIGTH;	WIDTH = drawingRect->right - drawingRect->left + 1;	HEIGTH = drawingRect->bottom - drawingRect->top + 1;	for (x = 0; x < WIDTH; x = x + 1)		for (y = 0; y < HEIGTH; y++)		{			r = (float)(65535 * x) / WIDTH;			g = (float)(65535 * y) / HEIGTH;			b = (float)(65535 * y) / WIDTH;			colPix.red = r;			colPix.green = g;			colPix.blue = b;			SetCPixel(x, y, &colPix);		}	*/	}void TPlasma::DrawShape(Rect *drawingRect){	OpenCPicParams	myOpenCPicParams;	PicHandle	myPic;	Rect 	rect;	rect.left = drawingRect->left;	rect.right = drawingRect->right;	rect.top = drawingRect->top;	rect.bottom = drawingRect->bottom;	myOpenCPicParams.srcRect = rect;	myOpenCPicParams.hRes = 0x00480000;	myOpenCPicParams.vRes = 0x00480000;	myOpenCPicParams.version = -2;	myOpenCPicParams.reserved1 = 0;	myOpenCPicParams.reserved2 = 0;		myPic = OpenCPicture(&myOpenCPicParams);		PenSize(style, style);	ClipRect(drawingRect);		while (drawingRect->left < drawingRect->right &&			drawingRect->top  < drawingRect->bottom) {		MoveTo(drawingRect->left, drawingRect->bottom);			LineTo(drawingRect->right, drawingRect->bottom);		LineTo(drawingRect->left, drawingRect->top);		LineTo(drawingRect->left, drawingRect->bottom);		InsetRect(drawingRect, style*2, style*2);	}		ClosePicture();	DrawPicture(myPic, &rect);}//// PREPARE STYLES METHODS//void TMandelbrot::PrepareStyles(){	short ci;	// Style 1	for(ci=0; ci < 256; ci++) {		spec[0][ci].red = 65536 - ci * 256;		spec[0][ci].green = 65536 - ci * 256;		spec[0][ci].blue = 65536 - ci * 256;	}	// Style 2	for(ci=0; ci < 256; ci++) {		spec[1][ci].red = ci * 256;		spec[1][ci].green = ci * 256;		spec[1][ci].blue = ci * 256;	}	// Style 2	for(ci=0; ci < 256; ci++) {		spec[2][ci].red = 65535 - ci * 256;		spec[2][ci].green = 32768 + ci * 128;		spec[2][ci].blue = ci * 256;	}	// Style 2	for(ci=0; ci < 256; ci++) {		spec[3][ci].red = ci * 256;		spec[3][ci].green = 32768 + ci * 128;		spec[3][ci].blue = 65535 - ci * 256;	}	// Style 2	for(ci=0; ci < 256; ci++) {		spec[4][ci].red = 32768 - ci * 128;		spec[4][ci].green = ci * 256;		spec[4][ci].blue = 65535 - ci * 256;	}}void TJulia::PrepareStyles(){	for(auto ci=0; ci < 256; ci++) {		spec[0][ci].red = 65536 - ci * 256;		spec[0][ci].green = 65536 - ci * 256;		spec[0][ci].blue = 65536 - ci * 256;	}	}//// ZOOM CONTENT//void TFractalViewerWindow::ZoomContent(short z){	RefreshWindow(false);		// preserve the scroll bars}void TMandelbrot::ZoomContent(short z){			switch (z) {		case -1:			pWidth = pWidth * 1.333;			pHeigth = pHeigth * 1.333;			break;		case 1:			pWidth = pWidth * 0.666;			pHeigth = pHeigth * 0.666;			break;			break;		default:			DefaultPlane();			break;	}	RefreshWindow(false);		// preserve the scroll bars}