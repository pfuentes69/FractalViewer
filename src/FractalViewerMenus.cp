/***** * objBullMenus.c * *	Copyright © 1991 Symantec Corporation. All rights reserved. * *	Menu handling routines for the Object Bullseye demo program. * *****/#include <oops.h>#include "FractalViewerMenus.h"#include "FractalViewerPrefs.h"#include "TFractalViewerWindow.h"#include "TMandelbrot.h"#include "TJulia.h"#include "TPlasma.h"	// prototypes for utility routinesstatic void enable (MenuHandle menu, short item, Boolean enableMenu);static findColorItem (long color);MenuHandle	appleMenu,			fileMenu,			editMenu,			styleMenu,			viewMenu;enum	{					// Menu ids			appleID = 1,			fileID,			editID,			styleID,			viewID};enum	{					// items in the File menu			mandelItem = 1,			juliaItem,			plasmaItem,			closeItem,			prefsItem = closeItem+2,	// leave space for the dashed line before Preferences			quitItem = prefsItem+2	// leave space for the dashed line before Quit};enum	{					// items in the File menu			restoreItem = 1,			zoomInItem,			zoomOutItem,			separatorItem,			FastModeItem,			NormalModeItem,			FineModeItem};/**** * SetUpMenus() * *	Set up the menus. * ****/void SetUpMenus(void){	InsertMenu(appleMenu = GetMenu(appleID), 0);	AddResMenu(appleMenu, 'DRVR');	InsertMenu(fileMenu = GetMenu(fileID), 0);	InsertMenu(editMenu = GetMenu(editID), 0);	InsertMenu(styleMenu = GetMenu(styleID), 0);	InsertMenu(viewMenu = GetMenu(viewID), 0);		DrawMenuBar();}/* end SetUpMenus *//**** *  AdjustMenus() * *	Enable or disable the items in the Edit menu if a DA window *	comes up or goes away. Our application doesn't do anything with *	the Edit menu. If one of our windows is frontmost, adjust the *	Width and color menus to reflect the proper values for the *	windows. * ****/#define	isEnabled(mH)	((**mH).enableFlags & 0x01)void AdjustMenus(void){	register WindowPeek wp = (WindowPeek) FrontWindow();	short kind = wp ? wp->windowKind : 0;	short	i;	short	max;	static short	redrawForEdit = true;	// did the Edit menu change?	static short	redrawForWidth = true;	// did the Width menu change?	if (kind < 0) {							// enable Edit for desk accessories	  redrawForEdit = !isEnabled(editMenu);	  enable(editMenu, 0, true);	}	else {									// disable it for all others	  redrawForEdit = isEnabled(editMenu);	  enable(editMenu, 0, false);	}	// enable the Close command for DAs and our windows	enable(fileMenu, closeItem, kind < 0 || kind == TWINDOWKIND);	// disable the Width and color menus if our window isn't frontmost	if (kind != TWINDOWKIND) {	  redrawForWidth = isEnabled(styleMenu);	  enable(styleMenu, 0, false);	  enable(viewMenu, 0, false);	}	else {	  redrawForWidth = !isEnabled(styleMenu);	  enable(styleMenu, 0, true);	  enable(viewMenu, 0, true);	  max = CountMItems(styleMenu);			// uncheck all the widths	  for (i = 1; i <= max; i++)	    CheckItem(styleMenu, i, false);	  max = CountMItems(viewMenu);			// uncheck all the colors	  for (i = 1; i <= max; i++) {	  	CheckItem(viewMenu, i, false);	  }		// check the style for the frontmost window	  CheckItem(styleMenu, OBJ(wp)->GetStyle(), true);		// check the drawMode for the frontmost window	  CheckItem(viewMenu, separatorItem + OBJ(wp)->GetDrawMode(), true);	}	if (redrawForEdit || redrawForWidth) {	  DrawMenuBar();	  redrawForEdit = redrawForWidth = false;	}}/** *	enable or disable a menu * **/static void enable (MenuHandle menu, short item, Boolean enableMenu){	if (enableMenu)		EnableItem(menu, item);	else		DisableItem(menu, item);}/** *	given an old QuickDraw color, find its menu item number * **//*static findColorItem (long color){	short	i;	short max = sizeof(colorTable) / sizeof(long);	for (i= 1; i <= max; i++)	  if (colorTable[i] == color)	    return i;	  else return 0;	DebugStr("\pBAD COLOR!");}*//***** * HandleMenu(mSelect) * *	Handle the menu selection. mSelect is what MenuSelect() and *	MenuKey() return: the high word is the menu ID, the low word *	is the menu item * *****/void HandleMenu (long mSelect){	short			menuID = HiWord(mSelect);	short			menuItem = LoWord(mSelect);	Str255		name;	GrafPtr		savePort;	TFractalViewerWindow	*fractalWindow;	WindowPeek	wp;		switch (menuID)	  {	  case	appleID:	  	if (menuItem == 1)	  	  {	  	  Alert(128, 0L);	  	  break;	  	  }	 		GetPort(&savePort);		GetItem(appleMenu, menuItem, name);		OpenDeskAcc(name);		SetPort(savePort);		break;		  case	fileID:		switch (menuItem)		  {		  case	mandelItem:		  	fractalWindow = new(TMandelbrot);		  	break;		  case 	juliaItem:		  	fractalWindow = new(TJulia);		  	break;		  			  case	plasmaItem:		  	fractalWindow = new(TPlasma);		  	break;		  		  case	closeItem:			if ((wp = (WindowPeek) FrontWindow()) == NULL)			  break;			  			if (wp->windowKind < 0)			  CloseDeskAcc(wp->windowKind);			else if (wp->windowKind == TWINDOWKIND)			  OBJ(wp)->Close();  			break;  			  		  case prefsItem:			HandlePrefs();  		  	break;  				  			  case	quitItem:			ExitToShell();			break;		  }		break;  					  case	editID:		if (!SystemEdit(menuItem-1))		  SysBeep(5);		break;			  case	styleID:		if ((wp = (WindowPeek) FrontWindow()) == 0L ||									wp->windowKind != TWINDOWKIND)		  break;		OBJ(wp)->SetStyle(menuItem);		break;	  case	viewID:		if ((wp = (WindowPeek) FrontWindow()) == 0L ||									wp->windowKind != TWINDOWKIND)			break;		switch (menuItem) {		  case	restoreItem:			OBJ(wp)->ZoomContent(0);		  	break;		  case 	zoomInItem:			OBJ(wp)->ZoomContent(+1);		  	break;		  			  case	zoomOutItem:			OBJ(wp)->ZoomContent(-1);		  	break;		  			  case	FastModeItem:			OBJ(wp)->SetDrawMode(1);		  	break;		  case 	NormalModeItem:			OBJ(wp)->SetDrawMode(2);		  	break;		  			  case	FineModeItem:			OBJ(wp)->SetDrawMode(3);		  	break;		  			  }		break;	  }}/* end HandleMenu */